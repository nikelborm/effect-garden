Help me decompose a service that would manage downloads of audio assets.

I have an application that features an interactive audio asset player

A user has 3 controls, that work like radio buttons, so only one option can be
selected in the list of possible options:

1. 8 accord options
2. 8 pattern options
3. 3 loudness options

So in summary we have 8+8+3=19 control buttons.

Each triplet of selected options (8*8*3=192 possible triplets) corresponds to a
specific audio asset.

A user has a play button and stop button, to control playback of currently
selected audio asset.

Initially when the screen is loaded, one of each options is selected by default.
This means that one asset immediately has the highest priority to be downloaded,
because the user may click play, and I want an asset to start playing
immediately, without waiting for it to be downloaded. Then after the immediate
asset is downloaded, there should be the next priority tier which corresponds to
all buttons, that could be pressed to change the asset. This would be 19 overall
buttons, and since 3 already selected by default, it means we have 16 potential
assets the user can switch to with a click of a mouse. So after the immediate
asset is completed, we need to start downloading other 16 potential assets, and
only then download the rest of backlog assets, also prioritized as 2 clicks
away.

When the user interface is loaded, asset manager should schedule filling up the
bank. Manager should utilize the bandwidth correctly, by not loading too many
assets at once, by downloading only the important assets first, and by skipping
downloading already present assets.

Let's say 6 parallel downloads will suffice, but if there are immediate assets
scheduled, they should be downloaded at max speed. So if there are at least 1
immediate asset, all other non immediate assets gracefully stop from being
downloaded, and then immediate assets start downloading. If there are more than
1 immediate assets, they start downloading in parallel, up until there are 6 of
them. When there are more than six of them, only 6 immediate assets are
downloaded at once, and the other immediate assets wait in the queue. It
generally applies to all tiers: try to download all assets at max speed in
immediate tier, then all in next-click tier, then all in backlog tier.

If an asset is downloaded and there happens tier switch, for example when some
assets are scheduled as background and we're in a state, where we download
background assets, but the user quickly clicks at 2 new options, which adds new
immediate task, we need to stop all tasks in all lower priority tiers, and start
executing higher priority tier tasks.

If some assets have been already in the process of downloading, but were
assigned a new tier, which made them the highest tier to currently scheduled, we
should not interrupt these tasks, but let them continue downloading, but
interrupt all tasks of lower tiers.

Assets can loose and gain priority after they are scheduled. We can change their
priority not only before they have started, but also mid-downloading. Example:

While we are downloading the default selected asset, a user can click to
select any other option in any of the 3 controls, so that will make our
previously immediate asset become second priority asset, and the new asset, that
could already be scheduled as background priority, become immediate assets.

Also I need to somehow fit the mechanism to change priority based on what option
the user is hovering their mouse, as it is more likely the option, the user will
click on, but also I need some form of debounce to not reschedule the
downloading tasks too quickly, because starting new requests, as well as
interrupting the old ones might be costly.

I also need a mechanism to when the task is rescheduled, make a request to start
downloading asset from a certain point. Since all assets, while they are
downloaded are streamed into opfs, we could already have some degree of
completion and don't need to requests the parts we already have.

Now, what potential flaws could be with this implementation, as well as what
potential ways and patterns could be used to implement this few priority tier
queue.
